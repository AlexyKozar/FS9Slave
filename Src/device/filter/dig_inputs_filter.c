#include "dig_inputs_filter.h"

#define NUM 20
uint16_t dInputRegResult = 0;   // результирующий регистр состояний входов

uint16_t dInputRegCapture = 0;  // регистр захвата дискретных входов

uint8_t cntDiTrue [16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};// массив счетчиков фреймов для переключения входов
uint8_t cntDiFalse[16] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};// массив счетчиков фреймов для переключения входов
/*
uint8_t cntDI_00 = 0, // счетчики фреймов для переключения входов
				cntDI_01 = 0,
				cntDI_02 = 0,
				cntDI_03 = 0,
				cntDI_04 = 0,
				cntDI_05 = 0,
				cntDI_06 = 0,
				cntDI_07 = 0,
				cntDI_08 = 0,
				cntDI_09 = 0,
				cntDI_10 = 0,
				cntDI_11 = 0,
				cntDI_12 = 0,
				cntDI_13 = 0,
				cntDI_14 = 0,
				cntDI_15 = 0;
*/				
uint16_t InputFilter(uint32_t *data, io_TypeDef *io_settings, uint8_t sum_dInputs)
{

	uint32_t frame = 0;
	uint8_t bufCntTrueBit = 0,
					bufCntFalseBit = 0;
	uint8_t cntHalfWave = 0,   // счетчик полуволн единиц
					cntZeroSpan = 0,   // счетчик нулевых промежутков
					cntChangesBit = 0;
	uint8_t longHalfWave[10] = {0,0,0,0,0,0,0,0,0,0};  // массив хранящий длинны полуволн
	
	uint8_t stateSignalFrame = 0; // результат в фрейме
	
	

	for(uint8_t i = 0; i < sum_dInputs; i++) // обрабатываем переданное количество входов по очереди
	{
		frame = data[i];
	
		switch(io_settings[i].type)
		{
			case 1:
			case 0: // если вход настроен как AC
			{	
				for(uint8_t a = 0; a < NUM; a++)
				{
					if( frame & (1 << a) )// если очередной бит кадра = 1 то
					{
						bufCntTrueBit ++;
						if((bufCntFalseBit != 0)&& //если счетчик нулей не пустой и нулей > 1
						   (bufCntTrueBit >= 2))//одна единица не сбрасвает 0
						{
							if( bufCntFalseBit >= 2) //если счетчик насчитал достаточное количетсво нулей для промежутка нуля
							{
								cntZeroSpan++;// засчитать положительную полуволну
							}	
							cntChangesBit++;
							bufCntFalseBit = 0;
						}
					}
					else // иначе если очередной бит кадра = 0
					{
						bufCntFalseBit++;
						if((bufCntTrueBit != 0)&& //если счетчик нулей не пустой и нулей > 1
						   (bufCntFalseBit >= 2))////один ноль не сбрасвает единицу
						{
							if( bufCntTrueBit >= 3) //если счетчик насчитал достаточное количетсво единиц для полуволны
							{
								cntHalfWave++;// засчитать положительную полуволну
								longHalfWave[cntHalfWave] = bufCntTrueBit; //записать длинну полуволны
							}	
							cntChangesBit++;
							bufCntTrueBit = 0;
						}
					}
				}	
				// если перебор окончен то проверить последние насчитанные счетчики	
				if(bufCntTrueBit >= 3) 
				{
					cntHalfWave++;// засчитать последний кусочек положительной полуволны
					longHalfWave[cntHalfWave] = bufCntTrueBit; //записать длинну полуволны
				}
				if(bufCntFalseBit >= 2) 
				{
					cntZeroSpan++;// засчитать последний кусочек положительной полуволны
				}
				
				bufCntTrueBit = 0;
				bufCntFalseBit = 0;
				// определяем состояние входа в текущем фрейме
				if((cntHalfWave >= 1) && (cntHalfWave <= 3)&&(cntChangesBit <= 5))stateSignalFrame = 1;
				else if(cntChangesBit > 5)stateSignalFrame = 2;
				else stateSignalFrame = 0;
				
				if(stateSignalFrame == 1)cntDiTrue[i]++;
				else cntDiFalse[i]++;
				
				if(stateSignalFrame == 2) // если определен переходной процесс то обнулить счетчик фильтрации
				{	cntDiTrue[i] = 0;
					cntDiFalse[i] = 0;
				}
				
				
				
				
				if( cntDiTrue[i] >= (io_settings[i].fltDuratiod/NUM) ) // проверка на сосчитывание счетчика до уставки длительности фильтрации
				{
					dInputRegResult |=  (1 << i); // установить соответствующий бит порта
					cntDiTrue[i] = 0;
					cntDiFalse[i] = 0;
				}
				if( cntDiFalse[i] >= io_settings[i].fltDuratiod/NUM ) // проверка на сосчитывание счетчика до уставки длительности фильтрации
				{
					dInputRegResult &= ~(1 << i); // сбросить соответствующий бит порта
					cntDiFalse[i] = 0;
					cntDiTrue[i] = 0;
				}	

				cntHalfWave = 0;
				cntZeroSpan = 0;
				cntChangesBit = 0;
				for(uint8_t t = 0;t < 10; t++)
				{
					longHalfWave[t] = 0;
				}
				break;
			}
			
			
			
			
			
			
			default:
			{
				break;
			}
			
			
		}//switch(io_settings[i].type)


		
	}//конец цикла анализа фреймов всех входов
	

	
	
	
	return dInputRegResult;
}

	/*
	data[i] = 0b 0000 0000 | 0000 0000 | 0000 0000 | 0000 0000 ; // сигнала нету
	data[0] = 0b 0000 0000 | 0000 1111 | 1111 0011 | 1111 1100 ; // сигнал есть 					1
	data[1] = 0b 0000 0000 | 0000 0011 | 1111 1100 | 1111 1111 ; // сигнал есть						1
	data[2] = 0b 0000 0000 | 0000 1111 | 1000 0111 | 1100 0011 ; // сигнал есть 0xf87C3		1
	data[3] = 0b 0000 0000 | 0000 1100 | 0001 1111 | 0000 0111 ; // сигнал есть 0xc1f07		1
	data[4] = 0b 0000 0000 | 0000 0011 | 1001 1100 | 1110 0111 ; // сигнал есть 0x39CE7		2
	data[5] = 0b 0000 0000 | 0000 1110 | 0011 1111 | 1000 1111 ; // сигнал есть 0xE3F8F		1
	data[6] = 0b 0000 0000 | 0000 0011 | 0100 0110 | 0001 1100 ; // сигнал есть 0x3461C		2
	data[7] = 0b 0000 0000 | 0000 0011 | 0100 0110 | 0000 1100 ; // сигнал есть 0x3461C		2
	data[8] = 0b 0000 0000 | 0000 1010 | 1010 1010 | 1010 1010 ; // сигнал есть 0xAAAAA		2
	data[9] = 0b 0000 0000 | 0000 1100 | 1100 1100 | 1100 1100 ; // сигнал есть 0xCCCCC		2
 data[10] = 0b 0000 0000 | 0000 0000 | 0001 0110 | 0101 1011 ; // сигнал есть 0x0165B		2
 data[11] = 0b 0000 0000 | 0000 1000 | 0110 1110 | 0001 1011 ; // сигнал есть 0x86E1B 	1
	*/
	/*
	После анализа кадра снятого со входа за 20мс нужно сделать следубщие выводы
		- в этом кадре логическая единица
		- в этом кадре логический ноль
		- этот кадр имеет переходной процесс который не может быть расценен как истина 
		или лож по такому кадру мы всеравно делаем захват сигнала и начинаем отсчитывать 
		длительность фильтрации
	Критерии опредиления сострояния сигнала в кадре:
			Для лгической единицы:
				1. буферный счетчик последовательных единиц в кадре определяет длинну полуволны
				2. счетчик засчитанных положительных полуволн в кадре (для не искробезопасного режима АС полуволн должно быть 2 или 3) 
	
				!один последующий ноль не может сбросить счетчик для окончания замера длинны полуволны необходимо 2 и более последовательных нуля
	
			Для логического нуля:
				1. буферный счетчик последовательных нулей в кадре
				2. счетчик нулевых промежутков в кадре
				
				!одна последующая единица не может сбросить счетчик нулей (единиц должно быть минимум 2)
		
		
			Для переходного процесса:
				счетчик смены состояний битов в кадре
				! если счетчик > 5 (первая положительная полуволна (или ее часть), промежуток нулей, вторая положительная полуволна (целиком), промежуток нулей, кусочек положительной полуволны) 
				то значит это переходной процесс
				
	!! Если за период фильтрации насчитанно больше 1-х последовательных переходных кадра то счетчик периода фильтрации обнуляется и начинаем набирать заново.
	!! Для измерения частоты сигнала используются только кадры с результатом = 1.
	!! Не забыть про диоды в ячейке даже не на искробезопасном режиме
	
	*/
	

